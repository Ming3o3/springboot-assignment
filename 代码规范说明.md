# 代码开发规范说明

## 1. 项目分层架构

本项目采用经典的三层架构设计，遵循职责分离原则：

### 1.1 表现层（Controller层）
**职责**：
- 接收前端请求
- 参数校验
- 调用Service层处理业务逻辑
- 返回响应结果

**规范**：
- 类名以`Controller`结尾
- 使用`@Controller`或`@RestController`注解
- 使用`@RequestMapping`定义请求路径
- 统一返回`Result<T>`对象
- 异常处理使用统一的异常处理器

**示例**：
```java
@Controller
@RequestMapping("/product")
public class ProductController {
    
    @Autowired
    private IProductService productService;
    
    @GetMapping("/api/list")
    @ResponseBody
    public Result<IPage<Product>> list(@RequestParam(defaultValue = "1") Integer current,
                                        @RequestParam(defaultValue = "10") Integer size) {
        IPage<Product> page = productService.getProductPage(current, size, null, null, null, null);
        return Result.success(page);
    }
}
```

### 1.2 业务逻辑层（Service层）
**职责**：
- 处理核心业务逻辑
- 数据验证
- 事务管理
- 调用Mapper层访问数据

**规范**：
- 接口以`I`开头，实现类以`Impl`结尾
- 使用`@Service`注解
- 复杂操作使用`@Transactional`注解保证事务一致性
- Service接口定义在`service`包，实现类在`service.impl`包

**示例**：
```java
// 接口
public interface IProductService extends IService<Product> {
    IPage<Product> getProductPage(Integer current, Integer size, ...);
}

// 实现类
@Service
public class ProductServiceImpl extends ServiceImpl<ProductMapper, Product> 
        implements IProductService {
    
    @Override
    @Cacheable(value = "products", key = "#current + '-' + #size")
    public IPage<Product> getProductPage(Integer current, Integer size, ...) {
        // 业务逻辑
    }
}
```

### 1.3 数据访问层（Mapper层）
**职责**：
- 数据库CRUD操作
- 自定义SQL查询

**规范**：
- 接口继承`BaseMapper<T>`
- 使用`@Mapper`注解
- 简单查询使用MyBatis-Plus内置方法
- 复杂查询使用`@Select`等注解或XML配置

**示例**：
```java
@Mapper
public interface ProductMapper extends BaseMapper<Product> {
    // 继承BaseMapper后自动拥有CRUD方法
    // 自定义查询示例
    @Select("SELECT * FROM products WHERE category = #{category}")
    List<Product> selectByCategory(@Param("category") String category);
}
```

### 1.4 实体层（Entity层）
**职责**：
- 数据库表映射
- 数据封装

**规范**：
- 使用`@TableName`指定表名
- 使用`@TableId`指定主键
- 使用`@TableField`指定字段映射
- 使用Lombok注解简化代码（@Data, @EqualsAndHashCode等）

**示例**：
```java
@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
@TableName("products")
public class Product implements Serializable {
    
    @TableId(value = "id", type = IdType.AUTO)
    private Long id;
    
    @TableField("product_name")
    private String productName;
    
    @TableField(value = "created_time", fill = FieldFill.INSERT)
    private LocalDateTime createdTime;
}
```

## 2. 命名规范

### 2.1 包命名
- 全部小写
- 使用点分隔符分隔层次
- 示例：`com.gzist.project.controller`

### 2.2 类命名
- 大驼峰命名法（PascalCase）
- 类名应该是名词
- 接口以`I`开头
- 实现类以`Impl`结尾
- Controller以`Controller`结尾
- Service以`Service`结尾
- Mapper以`Mapper`结尾

**示例**：
```
IUserService          // 接口
UserServiceImpl       // 实现类
ProductController     // 控制器
UserMapper            // Mapper
```

### 2.3 方法命名
- 小驼峰命名法（camelCase）
- 方法名应该是动词或动词短语
- 查询方法以`get`、`find`、`query`开头
- 新增方法以`add`、`save`、`insert`开头
- 修改方法以`update`、`modify`开头
- 删除方法以`delete`、`remove`开头
- 布尔方法以`is`、`has`、`can`开头

**示例**：
```java
getUserById(Long id)
findProductsByCategory(String category)
addProduct(Product product)
updateProduct(Product product)
deleteProduct(Long id)
isAdmin(User user)
```

### 2.4 变量命名
- 小驼峰命名法
- 成员变量不添加前缀
- 常量全大写，单词间下划线分隔
- 布尔变量不使用`is`前缀（已由getter方法体现）

**示例**：
```java
private String username;
private Integer productCount;
public static final String DEFAULT_ENCODING = "UTF-8";
private boolean active;  // getter: isActive()
```

### 2.5 数据库命名
- 表名、字段名全小写
- 单词间下划线分隔
- 表名使用复数
- 外键字段以`_id`结尾

**示例**：
```sql
users              -- 表名
product_name       -- 字段名
created_time       -- 字段名
user_id            -- 外键字段
```

## 3. 注解使用规范

### 3.1 实体类注解
```java
@Data                                    // Lombok：生成getter/setter
@EqualsAndHashCode(callSuper = false)   // Lombok：生成equals和hashCode
@Accessors(chain = true)                 // Lombok：链式调用
@TableName("products")                   // MyBatis-Plus：指定表名
```

### 3.2 字段注解
```java
@TableId(value = "id", type = IdType.AUTO)                // 主键，自增
@TableField("product_name")                               // 字段映射
@TableField(value = "created_time", fill = FieldFill.INSERT)  // 自动填充
```

### 3.3 Mapper注解
```java
@Mapper                                  // 标记为MyBatis的Mapper接口
@Select("SELECT * FROM users WHERE username = #{username}")
@Insert("INSERT INTO users (...) VALUES (...)")
@Update("UPDATE users SET ... WHERE id = #{id}")
@Delete("DELETE FROM users WHERE id = #{id}")
```

### 3.4 Service注解
```java
@Service                                 // 标记为Service组件
@Transactional(rollbackFor = Exception.class)  // 事务管理
@Cacheable(value = "products", key = "#id")    // 缓存
@CacheEvict(value = "products", allEntries = true)  // 清除缓存
```

### 3.5 Controller注解
```java
@Controller                              // 返回视图
@RestController                          // 返回JSON（@Controller + @ResponseBody）
@RequestMapping("/product")              // 请求路径映射
@GetMapping("/list")                     // GET请求
@PostMapping("/add")                     // POST请求
@PutMapping("/update")                   // PUT请求
@DeleteMapping("/delete/{id}")           // DELETE请求
@PreAuthorize("hasRole('ADMIN')")        // 权限控制
```

### 3.6 参数注解
```java
@RequestParam                            // 请求参数
@PathVariable                            // 路径变量
@RequestBody                             // 请求体（JSON）
@Valid                                   // 参数校验
```

## 4. 异常处理规范

### 4.1 Service层
- 使用`throw new RuntimeException("错误信息")`抛出异常
- 或自定义业务异常类

**示例**：
```java
public boolean addProduct(Product product, Long userId) {
    if (productMapper.selectByCode(product.getProductCode()) != null) {
        throw new RuntimeException("产品编码已存在");
    }
    return this.save(product);
}
```

### 4.2 Controller层
- 使用try-catch捕获异常
- 返回统一的错误响应

**示例**：
```java
@PostMapping("/api/add")
@ResponseBody
public Result<Void> add(@RequestBody Product product) {
    try {
        productService.addProduct(product, 1L);
        return Result.success("添加成功");
    } catch (Exception e) {
        return Result.error(e.getMessage());
    }
}
```

## 5. 注释规范

### 5.1 类注释
```java
/**
 * 产品Service接口
 *
 * @author GZIST
 * @since 2025-12-23
 */
public interface IProductService extends IService<Product> {
}
```

### 5.2 方法注释
```java
/**
 * 分页查询产品（支持条件查询）
 *
 * @param current 当前页
 * @param size 每页大小
 * @param productName 产品名称（模糊查询）
 * @return 分页结果
 */
IPage<Product> getProductPage(Integer current, Integer size, String productName);
```

### 5.3 字段注释
```java
/**
 * 用户ID（主键）
 */
@TableId(value = "id", type = IdType.AUTO)
private Long id;

/**
 * 产品价格
 */
@TableField("price")
private BigDecimal price;
```

### 5.4 复杂逻辑注释
```java
// 检查产品编码是否已存在
QueryWrapper<Product> wrapper = new QueryWrapper<>();
wrapper.eq("product_code", product.getProductCode());
if (productMapper.selectCount(wrapper) > 0) {
    throw new RuntimeException("产品编码已存在");
}
```

## 6. 代码格式规范

### 6.1 缩进
- 使用4个空格缩进
- 不使用Tab

### 6.2 行长度
- 每行不超过120个字符
- 超长的语句应换行

### 6.3 空行
- 方法之间空一行
- 逻辑块之间空一行
- import语句分组，组之间空一行

### 6.4 大括号
- 左大括号不换行
- 右大括号独占一行

```java
if (condition) {
    // 代码
} else {
    // 代码
}
```

## 7. SQL编写规范

### 7.1 关键字大写
```sql
SELECT * FROM users WHERE username = 'admin'
```

### 7.2 复杂查询格式化
```sql
SELECT 
    u.id, 
    u.username, 
    r.role_name
FROM users u
LEFT JOIN user_roles ur ON u.id = ur.user_id
LEFT JOIN roles r ON ur.role_id = r.id
WHERE u.status = 1
ORDER BY u.created_time DESC
```

### 7.3 避免使用SELECT *
- 明确指定需要的字段
- 提高查询性能

## 8. 配置文件规范

### 8.1 application.yml格式
- 使用YAML格式
- 层次清晰
- 添加注释说明

```yaml
# Spring Boot 配置文件
spring:
  # 应用名称
  application:
    name: product-management-system
  
  # 数据源配置
  datasource:
    url: jdbc:mysql://localhost:3306/product_management_system
    username: root
    password: root
```

## 9. 版本控制规范

### 9.1 Git提交信息
- feat: 新功能
- fix: 修复bug
- docs: 文档更新
- style: 代码格式调整
- refactor: 代码重构
- test: 测试相关
- chore: 构建/工具相关

**示例**：
```
feat: 添加产品批量删除功能
fix: 修复登录Session超时问题
docs: 更新README文档
```

## 10. 安全编码规范

### 10.1 密码处理
- 使用BCrypt加密
- 不在日志中输出密码
- 不在前端明文传输敏感信息

### 10.2 SQL注入防护
- 使用MyBatis参数化查询
- 使用`#{}`而非`${}`

### 10.3 XSS防护
- 前端对用户输入进行转义
- 后端验证数据格式

### 10.4 权限控制
- 使用`@PreAuthorize`注解
- 敏感操作需要权限验证

## 11. 性能优化规范

### 11.1 数据库查询
- 使用索引
- 避免N+1查询
- 使用分页查询

### 11.2 缓存使用
- 查询频繁的数据使用Redis缓存
- 数据修改后清除相关缓存

### 11.3 日志输出
- 生产环境使用INFO级别
- 开发环境使用DEBUG级别
- 避免过度日志输出

## 12. 测试规范

### 12.1 单元测试
- Service层方法需要单元测试
- 测试覆盖率不低于70%

### 12.2 集成测试
- 关键业务流程需要集成测试
- 测试数据使用独立数据库

---

**文档版本**: v1.0  
**最后更新**: 2025-12-23  
**维护者**: GZIST
